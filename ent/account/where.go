// Code generated by ent, DO NOT EDIT.

package account

import (
	"telegra/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		v := make([]any, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		v := make([]any, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// ShortName applies equality check predicate on the "short_name" field. It's identical to ShortNameEQ.
func ShortName(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortName), v))
	})
}

// AuthorName applies equality check predicate on the "author_name" field. It's identical to AuthorNameEQ.
func AuthorName(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthorName), v))
	})
}

// AuthorURL applies equality check predicate on the "author_url" field. It's identical to AuthorURLEQ.
func AuthorURL(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthorURL), v))
	})
}

// AccessToken applies equality check predicate on the "access_token" field. It's identical to AccessTokenEQ.
func AccessToken(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAccessToken), v))
	})
}

// AuthURL applies equality check predicate on the "auth_url" field. It's identical to AuthURLEQ.
func AuthURL(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthURL), v))
	})
}

// PageCount applies equality check predicate on the "page_count" field. It's identical to PageCountEQ.
func PageCount(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPageCount), v))
	})
}

// ShortNameEQ applies the EQ predicate on the "short_name" field.
func ShortNameEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortName), v))
	})
}

// ShortNameNEQ applies the NEQ predicate on the "short_name" field.
func ShortNameNEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldShortName), v))
	})
}

// ShortNameIn applies the In predicate on the "short_name" field.
func ShortNameIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldShortName), v...))
	})
}

// ShortNameNotIn applies the NotIn predicate on the "short_name" field.
func ShortNameNotIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldShortName), v...))
	})
}

// ShortNameGT applies the GT predicate on the "short_name" field.
func ShortNameGT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldShortName), v))
	})
}

// ShortNameGTE applies the GTE predicate on the "short_name" field.
func ShortNameGTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldShortName), v))
	})
}

// ShortNameLT applies the LT predicate on the "short_name" field.
func ShortNameLT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldShortName), v))
	})
}

// ShortNameLTE applies the LTE predicate on the "short_name" field.
func ShortNameLTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldShortName), v))
	})
}

// ShortNameContains applies the Contains predicate on the "short_name" field.
func ShortNameContains(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldShortName), v))
	})
}

// ShortNameHasPrefix applies the HasPrefix predicate on the "short_name" field.
func ShortNameHasPrefix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldShortName), v))
	})
}

// ShortNameHasSuffix applies the HasSuffix predicate on the "short_name" field.
func ShortNameHasSuffix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldShortName), v))
	})
}

// ShortNameEqualFold applies the EqualFold predicate on the "short_name" field.
func ShortNameEqualFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldShortName), v))
	})
}

// ShortNameContainsFold applies the ContainsFold predicate on the "short_name" field.
func ShortNameContainsFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldShortName), v))
	})
}

// AuthorNameEQ applies the EQ predicate on the "author_name" field.
func AuthorNameEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthorName), v))
	})
}

// AuthorNameNEQ applies the NEQ predicate on the "author_name" field.
func AuthorNameNEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAuthorName), v))
	})
}

// AuthorNameIn applies the In predicate on the "author_name" field.
func AuthorNameIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldAuthorName), v...))
	})
}

// AuthorNameNotIn applies the NotIn predicate on the "author_name" field.
func AuthorNameNotIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldAuthorName), v...))
	})
}

// AuthorNameGT applies the GT predicate on the "author_name" field.
func AuthorNameGT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAuthorName), v))
	})
}

// AuthorNameGTE applies the GTE predicate on the "author_name" field.
func AuthorNameGTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAuthorName), v))
	})
}

// AuthorNameLT applies the LT predicate on the "author_name" field.
func AuthorNameLT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAuthorName), v))
	})
}

// AuthorNameLTE applies the LTE predicate on the "author_name" field.
func AuthorNameLTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAuthorName), v))
	})
}

// AuthorNameContains applies the Contains predicate on the "author_name" field.
func AuthorNameContains(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAuthorName), v))
	})
}

// AuthorNameHasPrefix applies the HasPrefix predicate on the "author_name" field.
func AuthorNameHasPrefix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAuthorName), v))
	})
}

// AuthorNameHasSuffix applies the HasSuffix predicate on the "author_name" field.
func AuthorNameHasSuffix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAuthorName), v))
	})
}

// AuthorNameEqualFold applies the EqualFold predicate on the "author_name" field.
func AuthorNameEqualFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAuthorName), v))
	})
}

// AuthorNameContainsFold applies the ContainsFold predicate on the "author_name" field.
func AuthorNameContainsFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAuthorName), v))
	})
}

// AuthorURLEQ applies the EQ predicate on the "author_url" field.
func AuthorURLEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLNEQ applies the NEQ predicate on the "author_url" field.
func AuthorURLNEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLIn applies the In predicate on the "author_url" field.
func AuthorURLIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldAuthorURL), v...))
	})
}

// AuthorURLNotIn applies the NotIn predicate on the "author_url" field.
func AuthorURLNotIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldAuthorURL), v...))
	})
}

// AuthorURLGT applies the GT predicate on the "author_url" field.
func AuthorURLGT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLGTE applies the GTE predicate on the "author_url" field.
func AuthorURLGTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLLT applies the LT predicate on the "author_url" field.
func AuthorURLLT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLLTE applies the LTE predicate on the "author_url" field.
func AuthorURLLTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLContains applies the Contains predicate on the "author_url" field.
func AuthorURLContains(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLHasPrefix applies the HasPrefix predicate on the "author_url" field.
func AuthorURLHasPrefix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLHasSuffix applies the HasSuffix predicate on the "author_url" field.
func AuthorURLHasSuffix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLEqualFold applies the EqualFold predicate on the "author_url" field.
func AuthorURLEqualFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAuthorURL), v))
	})
}

// AuthorURLContainsFold applies the ContainsFold predicate on the "author_url" field.
func AuthorURLContainsFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAuthorURL), v))
	})
}

// AccessTokenEQ applies the EQ predicate on the "access_token" field.
func AccessTokenEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAccessToken), v))
	})
}

// AccessTokenNEQ applies the NEQ predicate on the "access_token" field.
func AccessTokenNEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAccessToken), v))
	})
}

// AccessTokenIn applies the In predicate on the "access_token" field.
func AccessTokenIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldAccessToken), v...))
	})
}

// AccessTokenNotIn applies the NotIn predicate on the "access_token" field.
func AccessTokenNotIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldAccessToken), v...))
	})
}

// AccessTokenGT applies the GT predicate on the "access_token" field.
func AccessTokenGT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAccessToken), v))
	})
}

// AccessTokenGTE applies the GTE predicate on the "access_token" field.
func AccessTokenGTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAccessToken), v))
	})
}

// AccessTokenLT applies the LT predicate on the "access_token" field.
func AccessTokenLT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAccessToken), v))
	})
}

// AccessTokenLTE applies the LTE predicate on the "access_token" field.
func AccessTokenLTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAccessToken), v))
	})
}

// AccessTokenContains applies the Contains predicate on the "access_token" field.
func AccessTokenContains(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAccessToken), v))
	})
}

// AccessTokenHasPrefix applies the HasPrefix predicate on the "access_token" field.
func AccessTokenHasPrefix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAccessToken), v))
	})
}

// AccessTokenHasSuffix applies the HasSuffix predicate on the "access_token" field.
func AccessTokenHasSuffix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAccessToken), v))
	})
}

// AccessTokenEqualFold applies the EqualFold predicate on the "access_token" field.
func AccessTokenEqualFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAccessToken), v))
	})
}

// AccessTokenContainsFold applies the ContainsFold predicate on the "access_token" field.
func AccessTokenContainsFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAccessToken), v))
	})
}

// AuthURLEQ applies the EQ predicate on the "auth_url" field.
func AuthURLEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAuthURL), v))
	})
}

// AuthURLNEQ applies the NEQ predicate on the "auth_url" field.
func AuthURLNEQ(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAuthURL), v))
	})
}

// AuthURLIn applies the In predicate on the "auth_url" field.
func AuthURLIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldAuthURL), v...))
	})
}

// AuthURLNotIn applies the NotIn predicate on the "auth_url" field.
func AuthURLNotIn(vs ...string) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldAuthURL), v...))
	})
}

// AuthURLGT applies the GT predicate on the "auth_url" field.
func AuthURLGT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAuthURL), v))
	})
}

// AuthURLGTE applies the GTE predicate on the "auth_url" field.
func AuthURLGTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAuthURL), v))
	})
}

// AuthURLLT applies the LT predicate on the "auth_url" field.
func AuthURLLT(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAuthURL), v))
	})
}

// AuthURLLTE applies the LTE predicate on the "auth_url" field.
func AuthURLLTE(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAuthURL), v))
	})
}

// AuthURLContains applies the Contains predicate on the "auth_url" field.
func AuthURLContains(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAuthURL), v))
	})
}

// AuthURLHasPrefix applies the HasPrefix predicate on the "auth_url" field.
func AuthURLHasPrefix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAuthURL), v))
	})
}

// AuthURLHasSuffix applies the HasSuffix predicate on the "auth_url" field.
func AuthURLHasSuffix(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAuthURL), v))
	})
}

// AuthURLEqualFold applies the EqualFold predicate on the "auth_url" field.
func AuthURLEqualFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAuthURL), v))
	})
}

// AuthURLContainsFold applies the ContainsFold predicate on the "auth_url" field.
func AuthURLContainsFold(v string) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAuthURL), v))
	})
}

// PageCountEQ applies the EQ predicate on the "page_count" field.
func PageCountEQ(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPageCount), v))
	})
}

// PageCountNEQ applies the NEQ predicate on the "page_count" field.
func PageCountNEQ(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPageCount), v))
	})
}

// PageCountIn applies the In predicate on the "page_count" field.
func PageCountIn(vs ...int) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldPageCount), v...))
	})
}

// PageCountNotIn applies the NotIn predicate on the "page_count" field.
func PageCountNotIn(vs ...int) predicate.Account {
	v := make([]any, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldPageCount), v...))
	})
}

// PageCountGT applies the GT predicate on the "page_count" field.
func PageCountGT(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPageCount), v))
	})
}

// PageCountGTE applies the GTE predicate on the "page_count" field.
func PageCountGTE(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPageCount), v))
	})
}

// PageCountLT applies the LT predicate on the "page_count" field.
func PageCountLT(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPageCount), v))
	})
}

// PageCountLTE applies the LTE predicate on the "page_count" field.
func PageCountLTE(v int) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPageCount), v))
	})
}

// HasPages applies the HasEdge predicate on the "pages" edge.
func HasPages() predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PagesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, PagesTable, PagesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPagesWith applies the HasEdge predicate on the "pages" edge with a given conditions (other predicates).
func HasPagesWith(preds ...predicate.Page) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PagesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, PagesTable, PagesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Account) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Account) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Account) predicate.Account {
	return predicate.Account(func(s *sql.Selector) {
		p(s.Not())
	})
}
